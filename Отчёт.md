# Отчёт

### Итак, наша цель: исследовать, как поведут себя различные алгоритмы поиска вхождений строки-шаблона в тексте на практике при работе с разными видами и размерами текстов.

Оценивать будем по количеству времени выполнения программы (с точностью до наносекунды). 

Далее графики сгруппированы по 5 штук на одно изображение для наглядности и удобства. 
Они расположены следующим образом:
```
- в верхнем ряду слева график с результатами замеров времени для массивов размера 50 - 300
- в верхнем правом углу график с результатами замеров времени для массивов размера 100 - 4100
- в нижнем левом углу график с результатами замеров количества элементарных операций для массивов размера 50 - 300
- в нижнем правом углу график с результатами замеров количества элементарных операций для массивов размера 100 - 4100
```
Если какой-либо из графиков хочется рассмотреть ближе, стоит обратиться к папке [Graphs](https://github.com/kamilarakhimova/hse-algo-hw2/blob/main/Graphs), найти по названию и полюбоваться на него там.

Всего алгоритмов было 4 + 4 их модификации для работы с символом подстановки [?], напомню каких:
```
1.1    наивный алгоритм (с использованием простого посимвольного сравнения)   ✔ 
1.2    модификация наивного алгоритма для работы с символом подстановки (?)    ✔ 
2.1    алгоритм Кнута-Морриса-Прата (с применением стандартных граней)    ✔ 
2.2    модификация алгоритма Кнута-Морриса-Прата (с применением стандартных граней) для работы с символом подстановки (?)    ✔ 
3.1    алгоритм Кнута-Морриса-Прата (с применением уточненных граней)    ✔ 
3.2    модификация алгоритма Кнута-Морриса-Прата (с применением уточненных граней) для работы с символом подстановки (?)    ✔ 
4.1    алгоритм Бойера-Мура-Хорспула    ✔
4.2    модификация алгоритма Бойера-Мура-Хорспула для работы с символом подстановки (?)    ✔
```

Также было 4 вида текстов:
```
1.    заполненный рандомно расположенными символами в бинарном алфавите {0, 1} размера 10000
2.    заполненный рандомно расположенными символами в бинарном алфавите {0, 1} размера 100000
3.    заполненный рандомно расположенными символами в днк-алфавите {a, b, c, d} размера 10000
4.    заполненный рандомно расположенными символами в днк-алфавите {a, b, c, d} размера 100000
```

> В этот раз после многократных запусков у меня получилось добиться графиков с не слишком сильными выбросами по времени. Наслаждайтесь!


Что ж, теперь начнём наш анализ с графиков для X символов подстановки, прокомментируем их, а в конце уже перейдём к "общей картине".

1. Без символов подстановки



2. С 1 символом подстановки




из статьи [Итмо](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82_%D0%9A%D0%BD%D1%83%D1%82%D0%B0-%D0%9C%D0%BE%D1%80%D1%80%D0%B8%D1%81%D0%B0-%D0%9F%D1%80%D0%B0%D1%82%D1%82%D0%B0): 
Алгоритм Кнута-Морриса-Пратта решает ту же задачу, что и алгоритм с применением одноименного автомата. Однако он не может работать с текстом, вводимым в режиме реального времени, ему нужно заранее знать текст, в котором нужно искать образец. Также, если текст достаточно объемный, алгоритм Кнута-Морриса-Пратта будет использовать гораздо больше памяти, чем приведенный выше в данной статье. Однако, если текст небольшой и дан заранее, алгоритм Кнута-Морриса-Пратта будет работать быстрее.
