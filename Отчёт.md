# Отчёт

### Итак, наша цель: исследовать, как поведут себя различные алгоритмы поиска вхождений строки-шаблона в тексте на практике при работе с разными видами и размерами текстов.

Оценивать будем по количеству времени выполнения программы (с точностью до наносекунды). 

Далее графики сгруппированы по 5 штук на одно изображение для наглядности и удобства. 
Они расположены следующим образом:
```
- в верхнем ряду слева график с результатами замеров времени для текста без символов подстановки
- в верхнем ряду посередине график с результатами замеров времени для текста с 1 символом подстановки
- в верхнем ряду справа график с результатами замеров времени для текста с 2 символами подстановки
- в нижнем ряду слева график с результатами замеров времени для текста с 3 символами подстановки
- в нижнем ряду справа график с результатами замеров времени для текста с 4 символами подстановки
```
Если какой-либо из графиков хочется рассмотреть ближе, стоит обратиться к папке [Graphs](https://github.com/kamilarakhimova/hse-algo-hw2/blob/main/Graphs), найти по названию и полюбоваться на него там.

Всего алгоритмов было 4 + 4 их модификации для работы с символом подстановки [?], напомню каких:
```
1.1    наивный алгоритм (с использованием простого посимвольного сравнения)   ✔ 
1.2    модификация наивного алгоритма для работы с символом подстановки (?)    ✔ 
2.1    алгоритм Кнута-Морриса-Прата (с применением стандартных граней)    ✔ 
2.2    модификация алгоритма Кнута-Морриса-Прата (с применением стандартных граней) для работы с символом подстановки (?)    ✔ 
3.1    алгоритм Кнута-Морриса-Прата (с применением уточненных граней)    ✔ 
3.2    модификация алгоритма Кнута-Морриса-Прата (с применением уточненных граней) для работы с символом подстановки (?)    ✔ 
4.1    алгоритм Бойера-Мура-Хорспула    ✔
4.2    модификация алгоритма Бойера-Мура-Хорспула для работы с символом подстановки (?)    ✔
```

Также было 4 вида текстов:
```
1.    заполненный рандомно расположенными символами в бинарном алфавите {0, 1} размера 10000
2.    заполненный рандомно расположенными символами в бинарном алфавите {0, 1} размера 100000
3.    заполненный рандомно расположенными символами в днк-алфавите {a, b, c, d} размера 10000
4.    заполненный рандомно расположенными символами в днк-алфавите {a, b, c, d} размера 100000
```

> В этот раз после многократных запусков у меня получилось добиться графиков с не слишком сильными выбросами по времени. Наслаждайтесь!


Что ж, теперь начнём наш анализ с графиков для определённых видов текста, прокомментируем их, а в конце уже перейдём к "общей картине".

1. Бинарный алфавит, размер 10000
![Merged_document](https://user-images.githubusercontent.com/58568615/231575638-9da1c10c-df37-444f-b7ad-c67ab149fbb1.png)
![Merged_document (2)](https://user-images.githubusercontent.com/58568615/231576463-f0478d0e-65fc-4147-9011-75f1977ae89c.png)

На таком небольшом размере текста прослеживается следующая тенденция, не зависящая от количества символов подстановки: лучше всего показывает себя наивный алгоритм, а хуже всего - алгоритм Бойера-Мура-Хорспула (далее БМХ). Различные реализации алгоритма КМП ведут себя более менее одинаково, по скорости работы приближаясь к наивному алгоритму, хоть и практически не обгоняя его. Также можно заметить, что алгоритм БМХ растёт экспоненциально параллельно с ростом размера шаблона, в то время как на остальные алгоритмы этот факт не играет почти никакой роли.
Что касается непосредственно замеров времени: абсолютно для каждого алгоритма при отсутствии символов подстановки в тексте замеры оказываются значительно ниже, нежели при их присутствии.

2. Бинарный алфавит, размер 100000
![Merged_document](https://user-images.githubusercontent.com/58568615/231577107-d55238fe-9a49-457d-a164-390156f1385d.png)
![Merged_document (1)](https://user-images.githubusercontent.com/58568615/231577124-d6520811-4db6-436e-ae6b-08ea29ca443d.png)

Здесь начинается интересное. Картина резко изменилась, теперь в лидеры выбился алгоритм БМХ. Наивный алгоритм всё ещё показывает себя лучше алгоритмов КМП, но так или иначе все они значительно уступают по времени работы алгоритму БМХ. При этом существенных различий в работе различных модификаций алгоритма КМП всё ещё не видно.
Теперь алгоритм БМХ ведёт себя гораздо спокойнее, не особо завися от роста размера строки-шаблона, как было ранее. Ситуация с замерами времени при разном количестве символов подстановки повторяется.

3. ДНК-алфавит, размер 10000
![Merged_document (2)](https://user-images.githubusercontent.com/58568615/231577361-8e915ca2-913a-4858-8334-dba4efe95eeb.png)
![Merged_document (3)](https://user-images.githubusercontent.com/58568615/231577453-07fc548c-59c1-422b-8fff-684a9f15e5a3.png)

В данных обстоятельствах ситуация не слишком отличается от ситуации, описанной в пункте 1. Всё также лучшим оказывается наивным алгоритм, а худшим вариантом - алгоритм БМХ. От изменения количества символов в алфавите ничего особо не поменялось по количеству потраченного на работу времени на практике.

4. ДНК-алфавит, размер 100000
![Merged_document (4)](https://user-images.githubusercontent.com/58568615/231577704-5910844d-469e-4908-88ce-5661d969e8a4.png)
![Merged_document (5)](https://user-images.githubusercontent.com/58568615/231577720-b835a94d-c444-4e86-9ea8-1263cb6efd0c.png)

А тут ситуация перекликается с той, что была описана в пункте 2. Опять поменялось положение игроков: БМХ показывает себя сильно лучше остальных. Однако появляется ещё один интересный момент: теперь чётче видна разница между реализациями алгоритма КМП и наивного алгоритма. Второй показывает себя заметно приятнее первого.

### Вывод:

Подведём итоги исследования. Не существует однозначно лучшего алгоритма для поиска подстроки-шаблона в тексте. Выбирать какой конкретно использовать в конкретном случае следует исходя из множества факторов. Например, таких, как размер входных данных, случайность генерации данных, мощность алфавита, необходимось работы в реальном времени, требуемые затраты на использование дополнительной памяти и пр. 

В ходе моей работы оказалось, что при небольшом размере текста (10000 символов) наивный алгоритм показывает себя лучше остальных изощрённых алгоритмов. Зато при увеличении размера текста (100000 символов) значительно приятнее других показывает себя алгоритм Бойера-Мура-Хорспула. А различные модификации алгоритма КМП (со стандартными/уточненными гранями) всегда выдают примерно схожие друг с другом результаты и практически всегда остаются в стабильных "середнячках".
При этом ни мощность алфавита, ни количество символов подстановки особо не влияют на расклад сил.

### Конец!
