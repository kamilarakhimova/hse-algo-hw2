# Отчёт

### Итак, наша цель: исследовать, как поведут себя различные алгоритмы поиска вхождений строки-шаблона в тексте на практике при работе с разными видами и размерами текстов.

Оценивать будем по количеству времени выполнения программы (с точностью до наносекунды). 

Далее графики сгруппированы по 5 штук на одно изображение для наглядности и удобства. 
Они расположены следующим образом:
```
- в верхнем ряду слева график с результатами замеров времени для текста без символов подстановки
- в верхнем ряду посередине график с результатами замеров времени для текста с 1 символом подстановки
- в верхнем ряду справа график с результатами замеров времени для текста с 2 символами подстановки
- в нижнем ряду слева график с результатами замеров времени для текста с 3 символами подстановки
- в нижнем ряду справа график с результатами замеров времени для текста с 4 символами подстановки
```
Если какой-либо из графиков хочется рассмотреть ближе, стоит обратиться к папке [Graphs](https://github.com/kamilarakhimova/hse-algo-hw2/blob/main/Graphs), найти по названию и полюбоваться на него там.

Всего алгоритмов было 4 + 4 их модификации для работы с символом подстановки [?], напомню каких:
```
1.1    наивный алгоритм (с использованием простого посимвольного сравнения)   ✔ 
1.2    модификация наивного алгоритма для работы с символом подстановки (?)    ✔ 
2.1    алгоритм Кнута-Морриса-Прата (с применением стандартных граней)    ✔ 
2.2    модификация алгоритма Кнута-Морриса-Прата (с применением стандартных граней) для работы с символом подстановки (?)    ✔ 
3.1    алгоритм Кнута-Морриса-Прата (с применением уточненных граней)    ✔ 
3.2    модификация алгоритма Кнута-Морриса-Прата (с применением уточненных граней) для работы с символом подстановки (?)    ✔ 
4.1    алгоритм Бойера-Мура-Хорспула    ✔
4.2    модификация алгоритма Бойера-Мура-Хорспула для работы с символом подстановки (?)    ✔
```

Также было 4 вида текстов:
```
1.    заполненный рандомно расположенными символами в бинарном алфавите {0, 1} размера 10000
2.    заполненный рандомно расположенными символами в бинарном алфавите {0, 1} размера 100000
3.    заполненный рандомно расположенными символами в днк-алфавите {a, b, c, d} размера 10000
4.    заполненный рандомно расположенными символами в днк-алфавите {a, b, c, d} размера 100000
```

> В этот раз после многократных запусков у меня получилось добиться графиков с не слишком сильными выбросами по времени. Наслаждайтесь!


Что ж, теперь начнём наш анализ с графиков для определённых видов текста, прокомментируем их, а в конце уже перейдём к "общей картине".

1. Бинарный алфавит, размер 10000
![Merged_document](https://user-images.githubusercontent.com/58568615/231575638-9da1c10c-df37-444f-b7ad-c67ab149fbb1.png)
![Merged_document (2)](https://user-images.githubusercontent.com/58568615/231576463-f0478d0e-65fc-4147-9011-75f1977ae89c.png)


2. Бинарный алфавит, размер 100000
![Merged_document](https://user-images.githubusercontent.com/58568615/231577107-d55238fe-9a49-457d-a164-390156f1385d.png)
![Merged_document (1)](https://user-images.githubusercontent.com/58568615/231577124-d6520811-4db6-436e-ae6b-08ea29ca443d.png)


3. ДНК-алфавит, размер 10000
![Merged_document (2)](https://user-images.githubusercontent.com/58568615/231577361-8e915ca2-913a-4858-8334-dba4efe95eeb.png)
![Merged_document (3)](https://user-images.githubusercontent.com/58568615/231577453-07fc548c-59c1-422b-8fff-684a9f15e5a3.png)


4. ДНК-алфавит, размер 100000
![Merged_document (4)](https://user-images.githubusercontent.com/58568615/231577704-5910844d-469e-4908-88ce-5661d969e8a4.png)
![Merged_document (5)](https://user-images.githubusercontent.com/58568615/231577720-b835a94d-c444-4e86-9ea8-1263cb6efd0c.png)




из статьи [Итмо](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82_%D0%9A%D0%BD%D1%83%D1%82%D0%B0-%D0%9C%D0%BE%D1%80%D1%80%D0%B8%D1%81%D0%B0-%D0%9F%D1%80%D0%B0%D1%82%D1%82%D0%B0): 
Алгоритм Кнута-Морриса-Пратта решает ту же задачу, что и алгоритм с применением одноименного автомата. Однако он не может работать с текстом, вводимым в режиме реального времени, ему нужно заранее знать текст, в котором нужно искать образец. Также, если текст достаточно объемный, алгоритм Кнута-Морриса-Пратта будет использовать гораздо больше памяти, чем приведенный выше в данной статье. Однако, если текст небольшой и дан заранее, алгоритм Кнута-Морриса-Пратта будет работать быстрее.
